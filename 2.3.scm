(define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence))
        )
    )
)

(define (map-m p sequence)
    (accumulate 
        (lambda (x y) 
            (cons (p x) y)
        )
        '() 
        sequence
    )
)
(define (append-m seq1 seq2)
    (accumulate cons seq2 seq1)
)
(define (length-m sequence)
    (accumulate (lambda (x y) (+ 1 y)) 0 sequence)
)
(define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-term) (+ (* x higher-term) this-coeff))
     0 coefficient-sequence)
)

(define (count-leaves-m t1)
    (accumulate + 0 (if (not (pair? t1)) (list 1) (map count-leaves-m t1)))
)
(define (accumulate-n op init seqs)
    (if (null? (car seqs))
    '()
    (cons (accumulate op init (accumulate (lambda (x y) (cons (car x) y)) '() seqs))
        (accumulate-n op init (accumulate (lambda (x y) (cons (cdr x) y)) '() seqs)))
    )
)

(define (dot-product v w)
   (accumulate + 0 (map * v w))
)

(define (matrix-*-vector m v)
    (map (lambda (r) (dot-product r v)) m)
)

(define (transpose mat)
    (accumulate-n (lambda (l r) (cons l r)) `() mat)
)
(define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
    (map (lambda (row) 
        (map (lambda (col) (dot-product row col)) cols)
        )
     m) 
    )
)

(define (fold-left op initial sequence)
    (define (iter result rest)
        (if (null? rest)
            result
            (iter (op result (car rest))
                (cdr rest)
            )
        )
    )
    (iter initial sequence)
)



(define (flatmap proc seq)
    (accumulate append `() (map proc seq))
)

(define (enumerate-interval s e)
    (if (> s e) `() (cons s (enumerate-interval (+ s 1) e)))
)
(define (unique-pair n)
    (flatmap (lambda (i) 
        (map 
            (lambda (j)
                (list i j)) 
        (enumerate-interval 1 (- i 1)))
    ) (enumerate-interval 1 n))
)
;;; exercise 2.41
(define (triple-pair n)
    (flatmap (lambda (i)
        (flatmap (lambda (j)
            (map 
                (lambda (k)
                    (list k j i))

                (enumerate-interval 1 (- j 1)))
                )
        (enumerate-interval 1 (- i 1))
        )
    ) 
    (enumerate-interval 1 n))
)
(define (filter-triple seq s)
    (filter (lambda (l)
        (= (accumulate + 0 l) s)
    ) seq)
)
(define (safe-map seq n)
(map (lambda (x)
                    (if 
                        (and 
                            (not (= 0 n)) (= n x))
                            1 0))
    seq)
)

(define (safe? k positions)
    (define (safe-ite sz seq)
       (if (= 1 sz) #t 
        (and 
            (= 
                (accumulate + 0  (safe-map  (cdr seq) (car seq))) 0)
                           (safe-ite (- sz 1) (cdr seq)))))
   (safe-ite k positions) 
)

(define (adjoin-position new-row k rest-of-queens)
    (define (adjoin-ite i seq)
        (if (= i k) 
            (list new-row)
        (cons (car seq) (adjoin-ite (+ i 1) (cdr seq)))
    )
    )
    (adjoin-ite 1 rest-of-queens)
)
(define (queen-flatmap rest-of-queens boardsize k)
    (flatmap (lambda (rest-of-queen)
    (map (lambda (new-row) (adjoin-position new-row k rest-of-queen)) (enumerate-interval 1 boardsize)))
    rest-of-queens)
)
(define (empty-board board-size)
    (define (empty-append-ite n)
        (if (= 1 n) (list 0) (cons 0 (empty-append-ite (- n 1))))
    )
    (list (empty-append-ite board-size))
)

(define (queens board-size)
    (define (queen-cols k)
        (if (= k 0)
            (empty-board board-size)    
            (filter 
                (lambda (positions)
                    (safe? k positions))
                (flatmap (lambda (rest-of-queens)
                    (map (lambda (new-row)
                        (adjoin-position new-row k rest-of-queens))
                        (enumerate-interval 1 board-size)))
                (queen-cols (- k 1)))
            ) 
        )
    )
    (queen-cols board-size)
)
   


(define (equal? a b)

    (cond ((and (null? a) (null? b)) #t)
    ((or (null? a) (null? b)) #f)
    ((and (pair? a) (pair? b)) (and (equal? (car a) (car b)) (equal? (cdr a) (cdr b))))
    ((or (pair? a) (pair? b)) #f)
    (else (eq? a b))
    ) 
)
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
(and (variable? v1) (variable? v2) (eq? v1 v2))
)
(define (=number? exp num)
(and (number? exp) (= exp num)))
(define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
    ((=number? a2 0) a1)
    ((and (number? a1) (number? a2)) (+ a1 a2))
    (else (list `+ a1 a2)))
)

(define (make-product m1 m2)
(list `* m1 m2)
)
(define (sum? x)
 (and (pair? x) (eq? (car x) `+))
)
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? x)
    (and (pair? x) (eq? (car x) `*))
)
(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))

(define (deriv exp var)
    (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp)
            (make-sum (deriv (addend exp) var) (deriv (augend exp) var))
        )
        ((product? exp)
            (make-sum 
                (make-product (multiplier exp) (deriv (multiplicand exp) var))
                (make-product (deriv (multiplier exp) var) (multiplicand exp)))
        )
        (else (error "unknown expression type -DERIV" exp))

    )
)
