(display "test")
(define (sum-integers a b)
    (if (> a b)
        0 (+ a (sum-integers (+a 1) b))))


(define (sum term a next b)
    (if (> a b)
        0
        (+ (term a)
            (sum term (next a) next b))))

(define (sum-ite term a next b ret)
    (if (> a b)
        ret
        (sum-ite term (next a) next b (+ ret (term a)))))


(define (cube a)
    (* a a a))
(define (inc n) (+ n 1))
(define (sum-cubes a b)
    (sum cube a inc b))
(define (sum-cubes-ite a b)
    (sum-ite cube a inc b 0))

(define (square-p a) 
    (if (= a 2) 2 (* a a)))
(define (inc-p a)
(+ a 2))

(define (product term a next b)
    (if ( a > b)
        1
        (* (term a) 
        (product term (next a) next b))
    )
)
(define (pi n)
    (/ 
    (product square-p 2 inc-p (* 2 n)) 
    (product square-p 3 inc-p (+ 1 (* 2 n)))
    )
)
(define (average a b) (/ (+ a b) 2))
(define (close-enough? x y) (< (abs (- x y)) 0.001))
(define (search f neg-point pos-point)
    (let ((midpoint (average neg-point pos-point)))
        (if (close-enough? neg-point pos-point)
            midpoint
            (let ((test-value (f midpoint)))
                (cond ((positive? test-value) (search f neg-point midpoint))
                    ((negative? test-value) (search f midpoint pos-point))
                    (else midpoint))
            )
        )
    )
)
(define (half-interval-method f a b)
    (let ((a-value (f a)) (b-value (f b)))
        (cond ((and (negative? a-value) (positive? b-value))
             (search f a b))
             ((and (negative? b-value) (positive? a-value))
             (search f b a))
             (else (error "Values are not of opposite sign " a b))
        )
    )
)

(define tolerance 0.00001)
(define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
        (display v2)
        (newline)
        (< (abs (- v1 v2)) tolerance))
    (define (try guess)
        (let ((next (f guess)))
            (if (close-enough? guess next)
                next (try next)
            )
        )
    )
    (try first-guess)
)
(define (count-frag n d k)
    (define (count-frag-inner a b)
        (cond ((= a b) (/ (n a) (d a)))
            (else  
                (/ (n a)
                    (+ (d a) 
                    (count-frag-inner (+ a 1) b)
                    )
                )
            )
        )
    )
    (define (count-frag-iterative a rt)
            (cond ((= a 0) rt)
                ((= a k) (count-frag-iterative (- a 1) (+ rt (/ (n a) (d a)))))
                (else 
                    (count-frag-iterative (- a 1) 
                        (/ (n a) (+ (d a) rt))
                    )
            )
            )
    )
    (count-frag-iterative k 0)
    ;;(count-frag-inner 1 k)
)
(define (count-frag-test k)
    (count-frag (lambda (i) 1.0) (lambda (i) 1.0) k))

(define (multiple i x) (cond ((= i 1) (- x))
    (else (* x (multiple (- i 1) x)))))

(define (d i) (- (* 2.0 i) 1))
(define (tan-cf x k)
    (- (count-frag (lambda (i) (multiple i x)) (lambda (i) (d i)) k))
)

(define (average-damp f) (lambda (x) (average x (f x))))

(define (sqrt x) (fixed-point (average-damp (lambda (y) (/ x y))) 1.0))
(define dx 0.00001)
(define (deriv g)
    (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))

(define (newton-transform g)
    (lambda (x)
        (- x (/ (g x) ((deriv g) x)))))
(define (newton-method g guess)
    (fixed-point (newton-transform g) guess))
(define (cubic a b c)
    (lambda (x) (+ (* x x x) (* a x x) (* b x) c)))

(define (double-m p)
    (lambda (x) (p (p x)))
)
(define (inc a) (+ a 1))
(define (compose f g)
    (lambda (x) (f (g x))))

(define (repeated p n)
    (lambda (x)
    (define (p-ite a i)
       (cond ((= a 1) (p i))
        (else (p-ite (- a 1) (p i)))
       )
    )
    (p-ite n x)
    )
)